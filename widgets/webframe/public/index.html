<html>
  <head>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      
      #proxy-iframe {
        width: 100%;
        height: 100vh;
        border: none;
      }
      
      .loading {
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        height: 100vh;
        font-family: sans-serif;
        color: #666;
      }
      
      .loading-text {
        margin-top: 10px;
        font-size: 14px;
      }
      
      .error {
        padding: 20px;
        color: #d32f2f;
        font-family: sans-serif;
        white-space: pre-wrap;
      }
    </style>
  </head>

  <body class="homey-widget">
    <div class="loading">
      <div>Loading...</div>
      <div class="loading-text" id="status"></div>
    </div>
    <iframe id="proxy-iframe" style="display: none;" sandbox="allow-same-origin allow-scripts allow-forms allow-popups"></iframe>
    
    <script type="text/javascript">
      function onHomeyReady(Homey) {
        Homey.ready();

        const url = Homey.getSettings().url;
        if (!url) {
          document.body.innerHTML = '<div class="error">Please configure a URL in the widget settings</div>';
          return;
        }

        const iframe = document.getElementById('proxy-iframe');
        const loading = document.querySelector('.loading');
        const statusEl = document.getElementById('status');
        
        // WebSocket state management
        const wsConnections = new Map();
        let wsIdCounter = 0;
        
        // Expose wsConnections to iframe
        window.wsConnections = wsConnections;

        function updateStatus(msg) {
          console.log(msg);
          statusEl.textContent = msg;
        }

        // Proxy function to make requests through Homey API
        async function proxyRequest(requestUrl, method = 'GET', headers = {}, data = null) {
          console.log('Making proxy request to:', requestUrl);
          
          try {
            const result = await Homey.api("POST", "/request", {
              url: requestUrl,
              method: method,
              headers: headers,
              data: data
            });
            
            console.log('Received response:', {
              success: result.success,
              status: result.status,
              contentType: result.contentType,
              dataLength: result.data ? result.data.length : 0
            });
            
            if (result.success === false) {
              throw new Error(result.error || 'Request failed');
            }
            
            return result;
          } catch (err) {
            console.error('Homey API error:', err);
            throw err;
          }
        }

        // WebSocket proxy functions
        async function wsConnect(wsUrl, wsId) {
          console.log('Connecting WebSocket:', wsUrl, 'with ID:', wsId);
          
          try {
            const result = await Homey.api("POST", "/ws_connect", {
              url: wsUrl,
              wsId: wsId
            });
            
            if (!result.success) {
              throw new Error(result.error || 'WebSocket connection failed');
            }
            
            return result;
          } catch (err) {
            console.error('WebSocket connect error:', err);
            throw err;
          }
        }

        async function wsSend(wsId, data) {
          try {
            // Convert data to base64
            let base64Data;
            if (data instanceof ArrayBuffer) {
              const uint8Array = new Uint8Array(data);
              base64Data = btoa(String.fromCharCode.apply(null, uint8Array));
            } else if (data instanceof Blob) {
              // For blobs, we need to read them first
              const arrayBuffer = await data.arrayBuffer();
              const uint8Array = new Uint8Array(arrayBuffer);
              base64Data = btoa(String.fromCharCode.apply(null, uint8Array));
            } else if (typeof data === 'string') {
              base64Data = btoa(unescape(encodeURIComponent(data)));
            } else {
              base64Data = btoa(String(data));
            }

            const result = await Homey.api("POST", "/ws_send", {
              wsId: wsId,
              data: base64Data
            });
            
            if (!result.success) {
              throw new Error(result.error || 'WebSocket send failed');
            }
            
            return result;
          } catch (err) {
            console.error('WebSocket send error:', err);
            throw err;
          }
        }

        async function wsClose(wsId) {
          try {
            const result = await Homey.api("POST", "/ws_close", {
              wsId: wsId
            });
            
            return result;
          } catch (err) {
            console.error('WebSocket close error:', err);
            throw err;
          }
        }

        // Better base64 decode that handles Unicode
        function base64DecodeUnicode(base64) {
          try {
            const binaryString = atob(base64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
            }
            return new TextDecoder('utf-8').decode(bytes);
          } catch (e) {
            console.error('Failed to decode base64:', e);
            return atob(base64);
          }
        }

        // Parse meta refresh tag from HTML
        function parseMetaRefresh(html, baseUrl) {
          const metaRefreshRegex = /<meta\s+http-equiv=["']refresh["']\s+content=["'](\d+);\s*url=([^"']+)["']\s*\/?>/i;
          const match = html.match(metaRefreshRegex);
          
          if (match) {
            const delay = parseInt(match[1], 10) || 0;
            let targetUrl = match[2].trim();
            
            try {
              targetUrl = new URL(targetUrl, baseUrl).href;
            } catch (e) {
              console.error('Failed to parse meta refresh URL:', e);
              return null;
            }
            
            console.log('Found meta refresh:', { delay, targetUrl });
            return { delay, targetUrl };
          }
          
          return null;
        }

        async function loadPage() {
          await loadPageFromUrl(url);
        }

        async function loadPageFromUrl(pageUrl) {
          try {
            updateStatus('Fetching page...');
            const result = await proxyRequest(pageUrl);
            
            updateStatus('Processing HTML...');
            console.log('Content type:', result.contentType);
            
            let htmlContent;
            try {
              htmlContent = base64DecodeUnicode(result.data);
              console.log('Decoded HTML length:', htmlContent.length);
            } catch (decodeError) {
              console.error('Decode error:', decodeError);
              throw new Error('Failed to decode response: ' + decodeError.message);
            }
            
            // Check for meta refresh
            const metaRefresh = parseMetaRefresh(htmlContent, pageUrl);
            if (metaRefresh) {
              console.log('Meta refresh detected, redirecting in', metaRefresh.delay, 'ms to', metaRefresh.targetUrl);
              updateStatus(`Redirecting in ${metaRefresh.delay}ms...`);
              
              setTimeout(() => {
                loadPageFromUrl(metaRefresh.targetUrl);
              }, metaRefresh.delay * 1000);
              
              return;
            }
            
            // Process HTML
            console.log('Injecting proxy script');
            const processed = injectProxyIntoHtml(htmlContent, pageUrl);
            console.log('Processed HTML length:', processed.length);
            
            updateStatus('Loading into frame...');
            
            iframe.srcdoc = processed;
            
            iframe.onload = function() {
              console.log('Iframe loaded');
              loading.style.display = 'none';
              iframe.style.display = 'block';
              updateStatus('Ready');
              
              // Start loading resources after iframe is ready
              setTimeout(() => {
                scanAndLoadResources();
              }, 100);
            };
            
          } catch (error) {
            console.error('Failed to load page:', error);
            showError('Failed to load page: ' + error.message + '\n\nCheck console for details.');
          }
        }

        function showError(msg) {
          document.body.innerHTML = '<div class="error">' + msg + '</div>';
        }

        // Expose navigation function
        window.handleProxyNavigation = async function(targetUrl) {
          console.log('Handling navigation to:', targetUrl);
          loading.style.display = 'flex';
          iframe.style.display = 'none';
          updateStatus('Loading...');
          
          try {
            await loadPageFromUrl(targetUrl);
          } catch (error) {
            console.error('Navigation failed:', error);
            showError('Failed to navigate: ' + error.message);
          }
        };

        // Process CSS to replace url() references with data URIs
        async function processCssUrls(cssContent, cssBaseUrl) {
          // Find all url() references in the CSS
          const urlRegex = /url\(\s*['"]?([^'")]+)['"]?\s*\)/gi;
          const urls = [];
          let match;
          
          // Collect all URLs
          while ((match = urlRegex.exec(cssContent)) !== null) {
            const url = match[1];
            // Skip data URIs and absolute HTTP(S) URLs from other domains
            if (!url.startsWith('data:') && !url.startsWith('http://') && !url.startsWith('https://')) {
              urls.push({ original: match[0], url: url });
            }
          }
          
          console.log('Found', urls.length, 'URLs in CSS to proxy');
          
          // Load and replace each URL
          for (const item of urls) {
            try {
              // Make URL absolute relative to the CSS file location
              const absoluteUrl = new URL(item.url, cssBaseUrl).href;
              console.log('Loading font/resource from CSS:', absoluteUrl);
              
              const result = await proxyRequest(absoluteUrl);
              
              // Get MIME type
              let mimeType = result.contentType || 'application/octet-stream';
              // Remove charset if present
              mimeType = mimeType.split(';')[0].trim();
              
              // Replace the url() with a data URI
              const dataUri = `url(data:${mimeType};base64,${result.data})`;
              cssContent = cssContent.replace(item.original, dataUri);
              
              console.log('Replaced', item.url, 'with data URI');
            } catch (error) {
              console.error('Failed to load resource from CSS:', item.url, error);
            }
          }
          
          return cssContent;
        }

        // Scan and load all resources
        async function scanAndLoadResources() {
          if (!iframe.contentDocument) {
            console.error('Cannot access iframe content');
            return;
          }

          console.log('Scanning for resources to load...');
          
          // Load images
          const images = iframe.contentDocument.querySelectorAll('img[data-proxy-src]');
          console.log('Found', images.length, 'images to load');
          for (let i = 0; i < images.length; i++) {
            const img = images[i];
            const imgUrl = img.getAttribute('data-proxy-src');
            if (!imgUrl) continue;
            
            try {
              // Convert to absolute URL
              const absoluteUrl = new URL(imgUrl, url).href;
              console.log('Loading image:', absoluteUrl);
              const result = await proxyRequest(absoluteUrl);
              
              if (result.status !== 200) {
                console.error('Failed to load image:', absoluteUrl, 'Status:', result.status);
                continue;
              }
              
              const contentType = result.contentType || 'image/png';
              img.src = `data:${contentType};base64,${result.data}`;
            } catch (error) {
              console.error('Failed to load image:', imgUrl, error);
            }
          }
          
          // Load stylesheets
          const links = iframe.contentDocument.querySelectorAll('link[data-proxy-href]');
          console.log('Found', links.length, 'stylesheets to load');
          for (let i = 0; i < links.length; i++) {
            const link = links[i];
            const cssUrl = link.getAttribute('data-proxy-href');
            if (!cssUrl) continue;
            
            try {
              // Convert to absolute URL
              const absoluteUrl = new URL(cssUrl, url).href;
              console.log('Loading stylesheet:', absoluteUrl);
              const result = await proxyRequest(absoluteUrl);
              
              if (result.status !== 200) {
                console.error('Failed to load stylesheet:', absoluteUrl, 'Status:', result.status);
                continue;
              }
              
              let cssContent = base64DecodeUnicode(result.data);
              
              // Process CSS to replace font URLs with data URIs
              cssContent = await processCssUrls(cssContent, absoluteUrl);
              
              const style = iframe.contentDocument.createElement('style');
              style.textContent = cssContent;
              link.parentNode.insertBefore(style, link.nextSibling);
            } catch (error) {
              console.error('Failed to load stylesheet:', cssUrl, error);
            }
          }
          
          // Process inline stylesheets
          const inlineStyles = iframe.contentDocument.querySelectorAll('style[data-proxy-process]');
          console.log('Found', inlineStyles.length, 'inline stylesheets to process');
          for (let i = 0; i < inlineStyles.length; i++) {
            const style = inlineStyles[i];
            const baseUrl = style.getAttribute('data-proxy-base-url');
            if (!baseUrl) continue;
            
            try {
              console.log('Processing inline stylesheet');
              let cssContent = style.textContent;
              
              // Process CSS to replace URLs with data URIs
              cssContent = await processCssUrls(cssContent, baseUrl);
              
              style.textContent = cssContent;
              style.removeAttribute('data-proxy-process');
              style.removeAttribute('data-proxy-base-url');
            } catch (error) {
              console.error('Failed to process inline stylesheet:', error);
            }
          }
          
          // Load scripts
          const scripts = iframe.contentDocument.querySelectorAll('script[data-proxy-src]');
          console.log('Found', scripts.length, 'scripts to load');
          for (let i = 0; i < scripts.length; i++) {
            const script = scripts[i];
            const scriptUrl = script.getAttribute('data-proxy-src');
            if (!scriptUrl) continue;
            
            try {
              // Convert to absolute URL
              const absoluteUrl = new URL(scriptUrl, url).href;
              console.log('Loading script:', absoluteUrl);
              const result = await proxyRequest(absoluteUrl);
              
              // Check if we got a valid response
              if (result.status !== 200) {
                console.error('Failed to load script:', absoluteUrl, 'Status:', result.status);
                continue;
              }
              
              // Check if content type is JavaScript
              const contentType = result.contentType || '';
              if (!contentType.includes('javascript') && !contentType.includes('ecmascript')) {
                console.warn('Script has unexpected content type:', contentType, 'for', absoluteUrl);
                // Continue anyway as some servers don't set the right content type
              }
              
              const jsContent = base64DecodeUnicode(result.data);
              
              const newScript = iframe.contentDocument.createElement('script');
              newScript.textContent = jsContent;
              script.parentNode.replaceChild(newScript, script);
            } catch (error) {
              console.error('Failed to load script:', scriptUrl, error);
            }
          }
          
          console.log('Finished loading resources');
        }

        // Expose fetch proxy for iframe
        window.handleProxyFetch = async function(url, method, headers, body) {
          console.log('Handling proxy fetch:', url);
          try {
            const result = await proxyRequest(url, method, headers, body);
            return {
              success: true,
              status: result.status,
              statusText: result.statusText,
              headers: result.headers,
              data: result.data,
              contentType: result.contentType
            };
          } catch (error) {
            console.error('Proxy fetch error:', error);
            return {
              success: false,
              error: error.message
            };
          }
        };

        // Expose WebSocket proxy for iframe
        window.handleProxyWebSocket = async function(wsUrl) {
          const wsId = `ws_${wsIdCounter++}`;
          console.log('Creating proxied WebSocket:', wsUrl, 'with ID:', wsId);
          
          // Set up event listeners for this specific WebSocket
          setupWebSocketListener(wsId);
          
          try {
            await wsConnect(wsUrl, wsId);
            return { success: true, wsId };
          } catch (error) {
            console.error('WebSocket proxy error:', error);
            return { success: false, error: error.message };
          }
        };

        window.handleProxyWebSocketSend = async function(wsId, data) {
          return await wsSend(wsId, data);
        };

        window.handleProxyWebSocketClose = async function(wsId) {
          const conn = wsConnections.get(wsId);
          if (conn) {
            wsConnections.delete(wsId);
          }
          return await wsClose(wsId);
        };

        // Set up WebSocket event listeners dynamically
        function setupWebSocketListener(wsId) {
          console.log('Setting up event listeners for:', wsId);
          
          Homey.on(`ws:${wsId}:open`, (data) => {
            console.log('WebSocket opened:', wsId);
            
            const conn = wsConnections.get(wsId);
            if (conn) {
              conn.readyState = 1; // OPEN
              if (conn._onopen) {
                conn._onopen({});
              }
            }
          });

          Homey.on(`ws:${wsId}:message`, (data) => {
            console.log('WebSocket message received:', wsId, data);
            
            const conn = wsConnections.get(wsId);
            if (conn && conn.onmessage) {
              try {
                // Decode base64 data
                const binaryString = atob(data.data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                  bytes[i] = binaryString.charCodeAt(i);
                }
                
                let messageData;
                
                // WebSocket servers often send text as binary frames
                // Try to decode as UTF-8 text first
                try {
                  const decoder = new TextDecoder('utf-8', { fatal: true });
                  messageData = decoder.decode(bytes);
                  console.log('Decoded as text:', messageData);
                } catch (e) {
                  // If UTF-8 decode fails, treat as binary
                  if (conn.binaryType === 'blob') {
                    messageData = new Blob([bytes]);
                  } else {
                    messageData = bytes.buffer;
                  }
                  console.log('Decoded as binary:', messageData);
                }
                
                // Create proper MessageEvent-like object
                const messageEvent = {
                  data: messageData,
                  type: 'message',
                  target: conn,
                  currentTarget: conn
                };
                
                conn.onmessage(messageEvent);
              } catch (error) {
                console.error('Error decoding WebSocket message:', error);
              }
            }
          });

          Homey.on(`ws:${wsId}:error`, (data) => {
            console.error('WebSocket error:', wsId, data.error);
            
            const conn = wsConnections.get(wsId);
            if (conn && conn.onerror) {
              conn.onerror(new Error(data.error));
            }
          });

          Homey.on(`ws:${wsId}:close`, (data) => {
            console.log('WebSocket closed:', wsId, data.code, data.reason);
            
            const conn = wsConnections.get(wsId);
            if (conn) {
              conn.readyState = 3; // CLOSED
              if (conn._onclose) {
                conn._onclose({ code: data.code, reason: data.reason });
              }
            }
            wsConnections.delete(wsId);
          });
        }

        function injectProxyIntoHtml(html, baseUrl) {
          // Remove or modify resource URLs in the HTML before browser parses it
          // This prevents 404 errors during initial load
          
          // Replace script src with data-proxy-src
          html = html.replace(/<script([^>]*)\ssrc=["']([^"']+)["']/gi, (match, attrs, src) => {
            return `<script${attrs} data-proxy-src="${src}"`;
          });
          
          // Replace link href for stylesheets with data-proxy-href
          html = html.replace(/<link([^>]*rel=["']stylesheet["'][^>]*)\shref=["']([^"']+)["']/gi, (match, attrs, href) => {
            return `<link${attrs} data-proxy-href="${href}"`;
          });
          html = html.replace(/<link([^>]*)\shref=["']([^"']+)["']([^>]*rel=["']stylesheet["'][^>]*)/gi, (match, attrs1, href, attrs2) => {
            return `<link${attrs1} data-proxy-href="${href}"${attrs2}`;
          });
          
          // Replace img src with data-proxy-src
          html = html.replace(/<img([^>]*)\ssrc=["']([^"']+)["']/gi, (match, attrs, src) => {
            // Skip data URIs
            if (src.startsWith('data:') || src.startsWith('blob:')) {
              return match;
            }
            return `<img${attrs} data-proxy-src="${src}"`;
          });
          
          const proxyScript = `
            <script>
            (function() {
              console.log('Proxy script initializing...');
              const baseUrl = '${baseUrl.replace(/'/g, "\\'")}';
              
              // Parse base URL
              const baseUrlObj = new URL(baseUrl);
              
              // Override location to make scripts think they're on the original server
              const originalLocation = window.location;
              const fakeLocation = {
                href: baseUrl,
                protocol: baseUrlObj.protocol,
                host: baseUrlObj.host,
                hostname: baseUrlObj.hostname,
                port: baseUrlObj.port,
                pathname: baseUrlObj.pathname,
                search: baseUrlObj.search,
                hash: baseUrlObj.hash,
                origin: baseUrlObj.origin,
                toString: function() { return baseUrl; },
                assign: function(url) { 
                  if (window.parent && window.parent.handleProxyNavigation) {
                    window.parent.handleProxyNavigation(new URL(url, baseUrl).href);
                  }
                },
                replace: function(url) { 
                  if (window.parent && window.parent.handleProxyNavigation) {
                    window.parent.handleProxyNavigation(new URL(url, baseUrl).href);
                  }
                },
                reload: function() {
                  if (window.parent && window.parent.handleProxyNavigation) {
                    window.parent.handleProxyNavigation(baseUrl);
                  }
                }
              };
              
              // Override window.location
              try {
                Object.defineProperty(window, 'location', {
                  get: function() { return fakeLocation; },
                  set: function(value) { 
                    if (window.parent && window.parent.handleProxyNavigation) {
                      window.parent.handleProxyNavigation(new URL(value, baseUrl).href);
                    }
                  }
                });
              } catch (e) {
                console.warn('Could not override window.location:', e);
              }
              
              // Override document.location
              try {
                Object.defineProperty(document, 'location', {
                  get: function() { return fakeLocation; },
                  set: function(value) { 
                    if (window.parent && window.parent.handleProxyNavigation) {
                      window.parent.handleProxyNavigation(new URL(value, baseUrl).href);
                    }
                  }
                });
              } catch (e) {
                console.warn('Could not override document.location:', e);
              }
              
              // Store WebSocket connections
              const wsConnections = new Map();
              
              // Override Image constructor to intercept new Image() calls
              const OriginalImage = window.Image;
              window.Image = function(width, height) {
                const img = new OriginalImage(width, height);
                
                // Override src property
                const originalSrcDescriptor = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, 'src');
                Object.defineProperty(img, 'src', {
                  get: function() {
                    return this.getAttribute('src') || '';
                  },
                  set: function(value) {
                    if (!value || value.startsWith('data:') || value.startsWith('blob:')) {
                      originalSrcDescriptor.set.call(this, value);
                      return;
                    }
                    
                    let absoluteUrl;
                    try {
                      absoluteUrl = new URL(value, baseUrl).href;
                    } catch (e) {
                      absoluteUrl = value;
                    }
                    
                    const urlObj = new URL(absoluteUrl);
                    if (urlObj.origin !== baseUrlObj.origin) {
                      const wrongPath = urlObj.pathname;
                      let fixedPath = wrongPath;
                      
                      const prefixes = [
                        '/app/nl.dypodex.proxy/widgets/webframe/',
                        '/widgets/webframe/',
                        '/webframe/'
                      ];
                      
                      for (const prefix of prefixes) {
                        if (fixedPath.startsWith(prefix)) {
                          fixedPath = fixedPath.substring(prefix.length);
                          break;
                        }
                      }
                      
                      absoluteUrl = new URL(fixedPath, baseUrl).href;
                    }
                    
                    console.log('Image constructor src set:', absoluteUrl);
                    
                    (async () => {
                      try {
                        const result = await window.parent.handleProxyFetch(absoluteUrl, 'GET', {}, null);
                        if (result.success && result.status === 200) {
                          const contentType = result.contentType || 'image/png';
                          originalSrcDescriptor.set.call(this, \`data:\${contentType};base64,\${result.data}\`);
                        }
                      } catch (error) {
                        console.error('Error loading image:', error);
                      }
                    }).call(this);
                  }
                });
                
                return img;
              };
              
              // Copy static properties
              window.Image.prototype = OriginalImage.prototype;
              
              // Override HTMLImageElement.prototype.src for all img elements
              const originalSrcDescriptor = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, 'src');
              if (originalSrcDescriptor && originalSrcDescriptor.configurable) {
                Object.defineProperty(HTMLImageElement.prototype, 'src', {
                  get: originalSrcDescriptor.get,
                  set: function(value) {
                    if (!value || value.startsWith('data:') || value.startsWith('blob:') || this.hasAttribute('data-proxy-processing')) {
                      originalSrcDescriptor.set.call(this, value);
                      return;
                    }
                    
                    this.setAttribute('data-proxy-processing', 'true');
                    
                    let absoluteUrl;
                    try {
                      absoluteUrl = new URL(value, baseUrl).href;
                    } catch (e) {
                      absoluteUrl = value;
                    }
                    
                    const urlObj = new URL(absoluteUrl);
                    if (urlObj.origin !== baseUrlObj.origin) {
                      const wrongPath = urlObj.pathname;
                      let fixedPath = wrongPath;
                      
                      const prefixes = [
                        '/app/nl.dypodex.proxy/widgets/webframe/',
                        '/widgets/webframe/',
                        '/webframe/'
                      ];
                      
                      for (const prefix of prefixes) {
                        if (fixedPath.startsWith(prefix)) {
                          fixedPath = fixedPath.substring(prefix.length);
                          break;
                        }
                      }
                      
                      absoluteUrl = new URL(fixedPath, baseUrl).href;
                    }
                    
                    console.log('HTMLImageElement.prototype.src set:', absoluteUrl);
                    
                    (async () => {
                      try {
                        const result = await window.parent.handleProxyFetch(absoluteUrl, 'GET', {}, null);
                        if (result.success && result.status === 200) {
                          const contentType = result.contentType || 'image/png';
                          this.removeAttribute('data-proxy-processing');
                          originalSrcDescriptor.set.call(this, \`data:\${contentType};base64,\${result.data}\`);
                        } else {
                          this.removeAttribute('data-proxy-processing');
                          console.error('Failed to load image:', absoluteUrl, result.status);
                        }
                      } catch (error) {
                        this.removeAttribute('data-proxy-processing');
                        console.error('Error loading image:', error);
                      }
                    }).call(this);
                  },
                  configurable: true
                });
              }
              
              // Override WebSocket constructor
              const OriginalWebSocket = window.WebSocket;
              window.WebSocket = function(url, protocols) {
                console.log('Intercepted WebSocket constructor:', url);
                
                // Make URL absolute
                let absoluteUrl;
                try {
                  absoluteUrl = new URL(url, baseUrl).href;
                } catch (e) {
                  console.error('Failed to parse WebSocket URL:', url, e);
                  absoluteUrl = url;
                }
                
                // Create a fake WebSocket object
                const fakeWs = {
                  url: absoluteUrl,
                  readyState: 0, // CONNECTING
                  bufferedAmount: 0,
                  extensions: '',
                  protocol: '',
                  binaryType: 'blob',
                  onopen: null,
                  onmessage: null,
                  onerror: null,
                  onclose: null,
                  CONNECTING: 0,
                  OPEN: 1,
                  CLOSING: 2,
                  CLOSED: 3
                };
                
                // Connect through parent proxy
                (async () => {
                  try {
                    const result = await window.parent.handleProxyWebSocket(absoluteUrl);
                    
                    if (!result.success) {
                      throw new Error(result.error || 'WebSocket connection failed');
                    }
                    
                    fakeWs.wsId = result.wsId;
                    
                    // Store reference in parent for event handling
                    if (window.parent.wsConnections) {
                      window.parent.wsConnections.set(result.wsId, fakeWs);
                    }
                    
                    // State will be updated when 'open' event is received
                  } catch (error) {
                    console.error('WebSocket connection error:', error);
                    fakeWs.readyState = 3; // CLOSED
                    if (fakeWs.onerror) {
                      setTimeout(() => fakeWs.onerror(error), 0);
                    }
                  }
                })();
                
                // Implement send method
                fakeWs.send = async function(data) {
                  if (this.readyState !== 1) { // OPEN
                    throw new Error('WebSocket is not open');
                  }
                  
                  try {
                    await window.parent.handleProxyWebSocketSend(this.wsId, data);
                  } catch (error) {
                    console.error('WebSocket send error:', error);
                    if (this.onerror) {
                      this.onerror(error);
                    }
                  }
                };
                
                // Implement close method
                fakeWs.close = async function(code, reason) {
                  if (this.readyState === 2 || this.readyState === 3) {
                    return; // Already closing or closed
                  }
                  
                  this.readyState = 2; // CLOSING
                  
                  try {
                    await window.parent.handleProxyWebSocketClose(this.wsId);
                  } catch (error) {
                    console.error('WebSocket close error:', error);
                  }
                };
                
                // Override onopen setter to update readyState
                Object.defineProperty(fakeWs, 'onopen', {
                  get: function() { return this._onopen; },
                  set: function(handler) {
                    this._onopen = function(event) {
                      fakeWs.readyState = 1; // OPEN
                      if (handler) handler.call(fakeWs, event);
                    };
                  }
                });
                
                // Override onclose setter to update readyState
                Object.defineProperty(fakeWs, 'onclose', {
                  get: function() { return this._onclose; },
                  set: function(handler) {
                    this._onclose = function(event) {
                      fakeWs.readyState = 3; // CLOSED
                      wsConnections.delete(fakeWs.wsId);
                      if (handler) handler.call(fakeWs, event);
                    };
                  }
                });
                
                return fakeWs;
              };
              
              // Copy static properties
              window.WebSocket.CONNECTING = 0;
              window.WebSocket.OPEN = 1;
              window.WebSocket.CLOSING = 2;
              window.WebSocket.CLOSED = 3;
              
              // Override fetch to use parent's proxy
              const originalFetch = window.fetch;
              window.fetch = async function(resource, init = {}) {
                const url = typeof resource === 'string' ? resource : resource.url;
                let absoluteUrl;
                try {
                  absoluteUrl = new URL(url, baseUrl).href;
                } catch (e) {
                  console.error('Failed to parse URL:', url, e);
                  absoluteUrl = url;
                }
                
                console.log('Intercepted fetch call:', absoluteUrl);
                
                try {
                  // Prepare headers as plain object
                  let headersObj = {};
                  if (init.headers) {
                    if (init.headers instanceof Headers) {
                      init.headers.forEach((value, key) => {
                        headersObj[key] = value;
                      });
                    } else if (typeof init.headers === 'object') {
                      headersObj = { ...init.headers };
                    }
                  }
                  
                  // Prepare body if present
                  let bodyData = init.body;
                  if (bodyData instanceof FormData) {
                    // Convert FormData to object
                    const formObj = {};
                    for (const [key, value] of bodyData.entries()) {
                      formObj[key] = value;
                    }
                    bodyData = JSON.stringify(formObj);
                  } else if (bodyData instanceof Blob) {
                    // Convert Blob to base64
                    bodyData = await new Promise((resolve) => {
                      const reader = new FileReader();
                      reader.onloadend = () => resolve(reader.result);
                      reader.readAsDataURL(bodyData);
                    });
                  }
                  
                  const result = await window.parent.handleProxyFetch(
                    absoluteUrl,
                    init.method || 'GET',
                    headersObj,
                    bodyData
                  );
                  
                  if (!result.success) {
                    throw new Error(result.error || 'Fetch failed');
                  }
                  
                  // Decode base64 response
                  const binaryString = atob(result.data);
                  const bytes = new Uint8Array(binaryString.length);
                  for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                  }
                  
                  // Create response with proper content type
                  const contentType = result.contentType || 'application/octet-stream';
                  const blob = new Blob([bytes], { type: contentType });
                  
                  // Build headers object
                  const responseHeaders = new Headers();
                  if (result.headers) {
                    for (const [key, value] of Object.entries(result.headers)) {
                      responseHeaders.set(key, value);
                    }
                  }
                  
                  return new Response(blob, {
                    status: result.status || 200,
                    statusText: result.statusText || 'OK',
                    headers: responseHeaders
                  });
                } catch (error) {
                  console.error('Fetch proxy error:', error);
                  throw error;
                }
              };
              
              // Override XMLHttpRequest to use parent's proxy
              const OriginalXHR = window.XMLHttpRequest;
              window.XMLHttpRequest = function() {
                const xhr = new OriginalXHR();
                const originalOpen = xhr.open;
                const originalSend = xhr.send;
                let requestMethod = 'GET';
                let requestUrl = '';
                let requestHeaders = {};
                
                xhr.open = function(method, url, ...args) {
                  requestMethod = method;
                  requestUrl = url;
                  
                  // Don't actually open the real XHR
                  return;
                };
                
                xhr.setRequestHeader = function(name, value) {
                  requestHeaders[name] = value;
                };
                
                xhr.send = async function(body) {
                  try {
                    let absoluteUrl;
                    try {
                      absoluteUrl = new URL(requestUrl, baseUrl).href;
                    } catch (e) {
                      absoluteUrl = requestUrl;
                    }
                    
                    console.log('Intercepted XHR call:', absoluteUrl);
                    
                    const result = await window.parent.handleProxyFetch(
                      absoluteUrl,
                      requestMethod,
                      requestHeaders,
                      body
                    );
                    
                    if (result.success) {
                      // Simulate successful response
                      Object.defineProperty(xhr, 'readyState', { value: 4, writable: false });
                      Object.defineProperty(xhr, 'status', { value: result.status || 200, writable: false });
                      Object.defineProperty(xhr, 'statusText', { value: result.statusText || 'OK', writable: false });
                      Object.defineProperty(xhr, 'responseText', { value: atob(result.data), writable: false });
                      Object.defineProperty(xhr, 'response', { value: atob(result.data), writable: false });
                      
                      if (xhr.onload) xhr.onload();
                      if (xhr.onreadystatechange) xhr.onreadystatechange();
                    } else {
                      Object.defineProperty(xhr, 'readyState', { value: 4, writable: false });
                      Object.defineProperty(xhr, 'status', { value: result.status || 500, writable: false });
                      
                      if (xhr.onerror) xhr.onerror();
                    }
                  } catch (error) {
                    console.error('XHR proxy error:', error);
                    if (xhr.onerror) xhr.onerror();
                  }
                };
                
                return xhr;
              };
              
              // Intercept dynamic script creation
              const originalCreateElement = document.createElement;
              document.createElement = function(tagName) {
                const element = originalCreateElement.call(document, tagName);
                
                if (tagName.toLowerCase() === 'script') {
                  const originalSetAttribute = element.setAttribute;
                  element.setAttribute = function(name, value) {
                    if (name.toLowerCase() === 'src') {
                      // Intercept src attribute
                      const originalSrc = value;
                      let absoluteUrl;
                      try {
                        absoluteUrl = new URL(value, baseUrl).href;
                      } catch (e) {
                        absoluteUrl = value;
                      }
                      
                      console.log('Intercepted dynamic script src:', absoluteUrl);
                      
                      // Check if this is trying to load from the wrong domain (Homey instead of original server)
                      const urlObj = new URL(absoluteUrl);
                      if (urlObj.origin !== baseUrlObj.origin) {
                        // Try to fix the path - extract the relative path and make it relative to baseUrl
                        const wrongPath = urlObj.pathname;
                        console.warn('Script URL has wrong origin:', absoluteUrl);
                        console.warn('Expected origin:', baseUrlObj.origin);
                        
                        // Try to extract the actual path after common prefixes
                        let fixedPath = wrongPath;
                        
                        // Remove common proxy path prefixes
                        const prefixes = [
                          '/app/nl.dypodex.proxy/widgets/webframe/',
                          '/widgets/webframe/',
                          '/webframe/'
                        ];
                        
                        for (const prefix of prefixes) {
                          if (fixedPath.startsWith(prefix)) {
                            fixedPath = fixedPath.substring(prefix.length);
                            break;
                          }
                        }
                        
                        // Construct new URL with correct origin
                        absoluteUrl = new URL(fixedPath, baseUrl).href;
                        console.log('Fixed URL to:', absoluteUrl);
                      }
                      
                      // Load via proxy
                      (async () => {
                        try {
                          const result = await window.parent.handleProxyFetch(absoluteUrl, 'GET', {}, null);
                          if (result.success && result.status === 200) {
                            const jsContent = atob(result.data);
                            element.textContent = jsContent;
                            // Trigger load event
                            if (element.onload) {
                              setTimeout(() => element.onload(), 0);
                            }
                          } else {
                            console.error('Failed to load dynamic script:', absoluteUrl, 'Status:', result.status);
                            if (element.onerror) {
                              setTimeout(() => element.onerror(new Error('Failed to load: ' + result.status)), 0);
                            }
                          }
                        } catch (error) {
                          console.error('Error loading dynamic script:', error);
                          if (element.onerror) {
                            setTimeout(() => element.onerror(error), 0);
                          }
                        }
                      })();
                      
                      // Don't set the actual src attribute
                      return;
                    }
                    return originalSetAttribute.call(element, name, value);
                  };
                  
                  // Also intercept direct src property assignment
                  Object.defineProperty(element, 'src', {
                    get: function() {
                      return this._proxySrc || '';
                    },
                    set: function(value) {
                      this._proxySrc = value;
                      this.setAttribute('src', value);
                    }
                  });
                }
                
                if (tagName.toLowerCase() === 'img') {
                  // Intercept img src changes
                  const originalSetAttribute = element.setAttribute;
                  element.setAttribute = function(name, value) {
                    if (name.toLowerCase() === 'src' && value && !value.startsWith('data:') && !value.startsWith('blob:')) {
                      let absoluteUrl;
                      try {
                        absoluteUrl = new URL(value, baseUrl).href;
                      } catch (e) {
                        absoluteUrl = value;
                      }
                      
                      // Check if wrong domain
                      const urlObj = new URL(absoluteUrl);
                      if (urlObj.origin !== baseUrlObj.origin) {
                        const wrongPath = urlObj.pathname;
                        let fixedPath = wrongPath;
                        
                        const prefixes = [
                          '/app/nl.dypodex.proxy/widgets/webframe/',
                          '/widgets/webframe/',
                          '/webframe/'
                        ];
                        
                        for (const prefix of prefixes) {
                          if (fixedPath.startsWith(prefix)) {
                            fixedPath = fixedPath.substring(prefix.length);
                            break;
                          }
                        }
                        
                        absoluteUrl = new URL(fixedPath, baseUrl).href;
                      }
                      
                      console.log('Intercepted dynamic img src:', absoluteUrl);
                      
                      // Load via proxy
                      (async () => {
                        try {
                          const result = await window.parent.handleProxyFetch(absoluteUrl, 'GET', {}, null);
                          if (result.success && result.status === 200) {
                            const contentType = result.contentType || 'image/png';
                            originalSetAttribute.call(element, 'src', \`data:\${contentType};base64,\${result.data}\`);
                          } else {
                            console.error('Failed to load dynamic image:', absoluteUrl, 'Status:', result.status);
                          }
                        } catch (error) {
                          console.error('Error loading dynamic image:', error);
                        }
                      })();
                      
                      return;
                    }
                    return originalSetAttribute.call(element, name, value);
                  };
                  
                  // Intercept direct src property
                  Object.defineProperty(element, 'src', {
                    get: function() {
                      return this.getAttribute('src') || '';
                    },
                    set: function(value) {
                      this.setAttribute('src', value);
                    }
                  });
                }
                
                return element;
              };
              
              // Intercept link clicks
              document.addEventListener('click', function(e) {
                let target = e.target;
                while (target && target.tagName !== 'A') {
                  target = target.parentElement;
                }
                
                if (!target) return;
                
                const href = target.getAttribute('href');
                if (!href || href.startsWith('#') || href.startsWith('javascript:') || 
                    href.startsWith('mailto:') || href.startsWith('tel:')) {
                  return;
                }
                
                try {
                  const linkUrl = new URL(href, baseUrl);
                  const baseUrlObj = new URL(baseUrl);
                  
                  if (linkUrl.origin === baseUrlObj.origin) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Intercepted link click:', linkUrl.href);
                    
                    if (window.parent && window.parent.handleProxyNavigation) {
                      window.parent.handleProxyNavigation(linkUrl.href);
                    }
                  }
                } catch (err) {
                  console.error('Failed to process link:', href, err);
                }
              }, true);
              
              // Mark resources for parent to load
              function markResources() {
                console.log('Marking resources for loading');
                
                // Mark images
                document.querySelectorAll('img[src]').forEach(img => {
                  const src = img.getAttribute('src');
                  if (src && !src.startsWith('data:') && !src.startsWith('blob:')) {
                    try {
                      const absoluteUrl = new URL(src, baseUrl).href;
                      img.setAttribute('data-proxy-src', absoluteUrl);
                      img.removeAttribute('src');
                    } catch (e) {
                      console.error('Failed to process image:', src, e);
                    }
                  }
                });
                
                // Mark stylesheets
                document.querySelectorAll('link[rel="stylesheet"]').forEach(link => {
                  const href = link.getAttribute('href');
                  if (href && !href.startsWith('data:') && !href.startsWith('blob:')) {
                    try {
                      const absoluteUrl = new URL(href, baseUrl).href;
                      link.setAttribute('data-proxy-href', absoluteUrl);
                      link.removeAttribute('href');
                    } catch (e) {
                      console.error('Failed to process stylesheet:', href, e);
                    }
                  }
                });
                
                // Mark inline stylesheets for processing
                document.querySelectorAll('style').forEach(style => {
                  // Only mark if it contains url() references
                  if (style.textContent && style.textContent.includes('url(')) {
                    style.setAttribute('data-proxy-process', 'true');
                    style.setAttribute('data-proxy-base-url', baseUrl);
                    console.log('Marked inline stylesheet for processing');
                  }
                });
                
                // Mark scripts
                document.querySelectorAll('script[src]').forEach(script => {
                  const src = script.getAttribute('src');
                  if (src && !src.startsWith('data:') && !src.startsWith('blob:')) {
                    try {
                      const absoluteUrl = new URL(src, baseUrl).href;
                      script.setAttribute('data-proxy-src', absoluteUrl);
                      script.removeAttribute('src');
                    } catch (e) {
                      console.error('Failed to process script:', src, e);
                    }
                  }
                });
                
                console.log('Resources marked');
              }
              
              if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', markResources);
              } else {
                markResources();
              }
              
              // Watch for dynamically added images and fix their src
              const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                  mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === 1) { // Element node
                      // Check if it's an image
                      if (node.tagName === 'IMG') {
                        fixImageSrc(node);
                      }
                      // Check for images in child nodes
                      const images = node.querySelectorAll ? node.querySelectorAll('img') : [];
                      images.forEach(img => fixImageSrc(img));
                    }
                  });
                  
                  // Also check for attribute changes on existing images
                  if (mutation.type === 'attributes' && mutation.attributeName === 'src') {
                    if (mutation.target.tagName === 'IMG') {
                      fixImageSrc(mutation.target);
                    }
                  }
                });
              });
              
              // Start observing
              observer.observe(document.documentElement, {
                childList: true,
                subtree: true,
                attributes: true,
                attributeFilter: ['src']
              });
              
              function fixImageSrc(img) {
                const src = img.getAttribute('src');
                if (!src || src.startsWith('data:') || src.startsWith('blob:') || img.hasAttribute('data-proxy-fixed')) {
                  return;
                }
                
                // Mark as being processed
                img.setAttribute('data-proxy-fixed', 'true');
                
                let absoluteUrl;
                try {
                  absoluteUrl = new URL(src, baseUrl).href;
                } catch (e) {
                  absoluteUrl = src;
                }
                
                // Check if wrong domain
                const urlObj = new URL(absoluteUrl);
                if (urlObj.origin !== baseUrlObj.origin) {
                  const wrongPath = urlObj.pathname;
                  let fixedPath = wrongPath;
                  
                  const prefixes = [
                    '/app/nl.dypodex.proxy/widgets/webframe/',
                    '/widgets/webframe/',
                    '/webframe/'
                  ];
                  
                  for (const prefix of prefixes) {
                    if (fixedPath.startsWith(prefix)) {
                      fixedPath = fixedPath.substring(prefix.length);
                      break;
                    }
                  }
                  
                  absoluteUrl = new URL(fixedPath, baseUrl).href;
                }
                
                console.log('Fixing image src via MutationObserver:', absoluteUrl);
                
                // Load via proxy
                (async () => {
                  try {
                    const result = await window.parent.handleProxyFetch(absoluteUrl, 'GET', {}, null);
                    if (result.success && result.status === 200) {
                      const contentType = result.contentType || 'image/png';
                      img.src = \`data:\${contentType};base64,\${result.data}\`;
                    } else {
                      console.error('Failed to load image via observer:', absoluteUrl, 'Status:', result.status);
                    }
                  } catch (error) {
                    console.error('Error loading image via observer:', error);
                  }
                })();
              }
              
              console.log('Proxy script initialized');
            })();
            </` + `script>`;
          
          // Inject script at the beginning of head or body
          if (html.includes('<head>')) {
            return html.replace('<head>', '<head>' + proxyScript);
          } else if (html.includes('</head>')) {
            return html.replace('</head>', proxyScript + '</head>');
          } else if (html.includes('<body')) {
            return html.replace(/<body([^>]*)>/, '<body$1>' + proxyScript);
          } else {
            return proxyScript + html;
          }
        }

        console.log('Starting page load for:', url);
        loadPage();
      }
    </script>
  </body>
</html>